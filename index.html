<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>DOCX Viewer - Explore and Edit Word Documents</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.53.0/min/vs/loader.js"></script>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <div id="viewerHeader" style="
        padding: 5px 10px;
        background: #252526;
        color: #d4d4d4;
        font-size: 14px;
        border-bottom: 1px solid #333;
      ">
    No file selected
  </div>
  <div id="viewerContainer">
    <div id="fileTreeContainer">
      <header>
        <input id="fileSearch" type="text" placeholder="Search files..." />
        <button id="uploadBtn">Upload File</button>
      </header>
      <div id="fileTree"></div>
    </div>
    <div id="editorWrapper">
      <div id="tabsContainer"></div>
      <div id="editorLoading">Loading...</div>
      <div id="editorContainer"></div>
      <div id="imageContainer" style="
            display: none;
            width: 100%;
            height: 100%;
            justify-content: center;
            align-items: center;
          ">
        <img id="docxImage" src="" style="max-width: 100%; max-height: 100%; object-fit: contain" />
      </div>
    </div>
  </div>

  <div id="fullScreenOverlay">
    <div id="welcomeSection" role="button" tabindex="0">
      <h2>DOCX Viewer</h2>
      <p>Explore and edit Word document internals</p>
      <p class="subtitle">Click here or drag a file to get started</p>
      <span class="file-format">Supports .docx files</span>
    </div>
    <div id="recentFiles">
      <h3>Recent Documents</h3>
      <div id="recentFilesList">
        <div id="noRecentFiles">No recent files</div>
      </div>
    </div>
  </div>

  <script>
    const fileTreeDiv = document.getElementById("fileTree");
    const uploadBtn = document.getElementById("uploadBtn");
    const fileSearch = document.getElementById("fileSearch");
    const editorContainer = document.getElementById("editorContainer");
    const editorLoading = document.getElementById("editorLoading");
    const fullScreenOverlay = document.getElementById("fullScreenOverlay");
    const imageContainer = document.getElementById("imageContainer");
    const docxImage = document.getElementById("docxImage");
    const editorHeader = document.getElementById("viewerHeader");
    const tabsContainer = document.getElementById("tabsContainer");
    const recentFilesList = document.getElementById("recentFilesList");
    const welcomeSection = document.getElementById("welcomeSection");

    function setActiveFileHeader(filename) {
      editorHeader.textContent = filename || "No file selected";
      docxName = filename
    }

    let zipFilesMap = {};
    let monacoEditor;
    let xmlWorker;
    const fileCache = {};
    let selectedFileLi = null;
    let docxName;
    let openTabs = [];
    let activeTabPath = null;
    let currentFileData = null;

    // Supported image extensions
    const imageExtensions = [".png", ".jpg", ".jpeg", ".gif", ".bmp"];
    function isImageFile(path) {
      const ext = path.slice(path.lastIndexOf(".")).toLowerCase();
      return imageExtensions.includes(ext);
    }

    /* -------------------- IndexedDB -------------------- */
    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open("docxViewerDB", 2);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains("files"))
            db.createObjectStore("files", {keyPath: "path"});
          if (!db.objectStoreNames.contains("recentFiles"))
            db.createObjectStore("recentFiles", {keyPath: "name"});
        };
        request.onsuccess = (e) => resolve(e.target.result);
        request.onerror = (e) => reject(e.target.error);
      });
    }

    async function saveFileToDB(path, content) {
      const db = await openDB();
      const tx = db.transaction("files", "readwrite");
      tx.objectStore("files").put({path, content});
      return new Promise((resolve) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => resolve();
      });
    }

    async function loadFileFromDB(path) {
      const db = await openDB();
      return new Promise((resolve) => {
        const tx = db.transaction("files", "readonly");
        const req = tx.objectStore("files").get(path);
        req.onsuccess = () => resolve(req.result?.content || null);
        req.onerror = () => resolve(null);
      });
    }

    async function saveRecentFile(name, fileData) {
      const db = await openDB();
      const tx = db.transaction("recentFiles", "readwrite");
      tx.objectStore("recentFiles").put({
        name,
        timestamp: Date.now(),
        data: fileData
      });
      return new Promise((resolve) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => resolve();
      });
    }

    async function getRecentFiles() {
      const db = await openDB();
      return new Promise((resolve) => {
        const tx = db.transaction("recentFiles", "readonly");
        const req = tx.objectStore("recentFiles").getAll();
        req.onsuccess = () => {
          const files = req.result || [];
          files.sort((a, b) => b.timestamp - a.timestamp);
          resolve(files.slice(0, 10));
        };
        req.onerror = () => resolve([]);
      });
    }

    async function deleteRecentFile(name) {
      const db = await openDB();
      const tx = db.transaction("recentFiles", "readwrite");
      tx.objectStore("recentFiles").delete(name);
      return new Promise((resolve) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => resolve();
      });
    }

    /* -------------------- File Input / Drag Drop -------------------- */
    const hiddenInput = document.createElement("input");
    hiddenInput.type = "file";
    hiddenInput.accept = ".docx";
    hiddenInput.style.display = "none";
    document.body.appendChild(hiddenInput);

    uploadBtn.addEventListener("click", () => {
      hiddenInput.value = "";
      hiddenInput.click();
    });
    hiddenInput.addEventListener("change", (e) => {
      handleFile(e.target.files[0]);
      fullScreenOverlay.style.display = "none";
    });
    welcomeSection.addEventListener("click", () => {
      hiddenInput.value = "";
      hiddenInput.click();
    });
    welcomeSection.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        hiddenInput.value = "";
        hiddenInput.click();
      }
    });

    ["dragover", "drop"].forEach((evt) => {
      document.addEventListener(evt, (e) => e.preventDefault());
    });
    fullScreenOverlay.addEventListener("drop", (e) => {
      handleFile(e.dataTransfer.files[0]);
      fullScreenOverlay.style.display = "none";
    });
    fullScreenOverlay.addEventListener("dragover", (e) => {
      fullScreenOverlay.style.background = "rgba(40,40,40,0.95)";
    });
    fullScreenOverlay.addEventListener("dragleave", (e) => {
      fullScreenOverlay.style.background = "rgba(30,30,30,0.95)";
    });

    /* -------------------- DOCX Loading -------------------- */
    async function handleFile(file, fromRecent = false) {
      if (!file) return;

      let arrayBuffer;
      if (fromRecent) {
        arrayBuffer = file;
      } else {
        arrayBuffer = await file.arrayBuffer();
        const fileName = file.name;
        await saveRecentFile(fileName, arrayBuffer);
        await renderRecentFiles();
      }

      const zip = await JSZip.loadAsync(arrayBuffer);
      zipFilesMap = {};
      Object.keys(zip.files).forEach((path) => {
        if (!zip.files[path].dir) zipFilesMap[path] = zip.files[path];
      });
      const tree = buildTree(Object.keys(zipFilesMap));
      fileTreeDiv.innerHTML = "";
      fileTreeDiv.appendChild(renderTree(tree));

      if (!fromRecent) {
        setActiveFileHeader(file.name);
      }

      openTabs = [];
      activeTabPath = null;
      renderTabs();
      if (monacoEditor) monacoEditor.setValue("");
    }

    function buildTree(files) {
      const root = {};
      files.forEach((path) => {
        const parts = path.split("/");
        let cur = root;
        parts.forEach((part, idx) => {
          cur[part] = cur[part] || (idx === parts.length - 1 ? null : {});
          cur = cur[part] || {};
        });
      });
      return root;
    }

    function getFileClass(path) {
      if (isImageFile(path)) return "file file-image";
      if (path.endsWith(".xml")) return "file file-xml";
      if (path.endsWith(".txt")) return "file file-text";
      if (path.match(/\.(ttf|otf|woff|woff2)$/i)) return "file file-font";
      return "file file-default";
    }

    /* -------------------- File Tree Rendering -------------------- */
    function renderTree(obj, path = "") {
      const ul = document.createElement("ul");
      Object.keys(obj)
        .sort((a, b) => {
          const aF = obj[a] !== null,
            bF = obj[b] !== null;
          if (aF && !bF) return -1;
          if (!aF && bF) return 1;
          return a.localeCompare(b);
        })
        .forEach((key) => {
          const fullPath = path ? path + "/" + key : key;
          const li = document.createElement("li");

          const labelDiv = document.createElement("div");
          labelDiv.className = "labelContainer";
          const nameSpan = document.createElement("span");
          nameSpan.textContent = key;
          nameSpan.className = "fileName";
          labelDiv.appendChild(nameSpan);

          li.appendChild(labelDiv);
          if (obj[key]) {
            li.className = "folder collapsed";
            const childUl = renderTree(obj[key], fullPath);
            li.appendChild(childUl);
            labelDiv.addEventListener("click", (e) => {
              e.stopPropagation();
              li.classList.toggle("collapsed");
              childUl.style.display = li.classList.contains("collapsed")
                ? "none"
                : "block";
            });
          } else {
            li.className = getFileClass(fullPath);

            // Three-dot menu
            const actionsDiv = document.createElement("div");
            actionsDiv.className = "fileActionsMenu";
            const toggle = document.createElement("span");
            toggle.textContent = "⋮";
            toggle.className = "menuToggle";
            const dropdown = document.createElement("div");
            dropdown.className = "fileActionsDropdown";
            const copyBtn = document.createElement("button");
            copyBtn.textContent = "Copy Path";
            const downloadBtn = document.createElement("button");
            downloadBtn.textContent = "Download";
            dropdown.appendChild(copyBtn);
            dropdown.appendChild(downloadBtn);
            actionsDiv.appendChild(toggle);
            actionsDiv.appendChild(dropdown);
            labelDiv.appendChild(actionsDiv);

            toggle.addEventListener("click", (e) => {
              e.stopPropagation();
              actionsDiv.classList.toggle("open");
            });
            copyBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              navigator.clipboard.writeText(fullPath);
              actionsDiv.classList.remove("open");
            });
            downloadBtn.addEventListener("click", async (e) => {
              e.stopPropagation();
              const fd = zipFilesMap[fullPath];
              if (!fd) return;
              const blob = await fd.async("blob");
              const a = document.createElement("a");
              a.href = URL.createObjectURL(blob);
              a.download = fullPath.split("/").pop();
              a.click();
              actionsDiv.classList.remove("open");
            });

            labelDiv.addEventListener("click", async (e) => {
              e.stopPropagation();
              if (selectedFileLi) selectedFileLi.classList.remove("selected");
              li.classList.add("selected");
              selectedFileLi = li;

              const fd = zipFilesMap[fullPath];
              if (!fd) return;

              const fileName = fullPath.split("/").pop();

              // Handle images
              if (isImageFile(fullPath)) {
                const blob = await fd.async("blob");
                const url = URL.createObjectURL(blob);
                openTab(fullPath, fileName, url, "image");
                return;
              }

              // Check in-memory cache
              if (fileCache[fullPath]) {
                const type = fullPath.endsWith(".xml") ? "xml" : "plaintext";
                openTab(fullPath, fileName, fileCache[fullPath], type);
                return;
              }

              // Check IndexedDB
              const cached = await loadFileFromDB(docxName + "/" + fullPath);
              if (cached) {
                fileCache[fullPath] = cached;
                const type = fullPath.endsWith(".xml") ? "xml" : "plaintext";
                openTab(fullPath, fileName, cached, type);
                return;
              }

              // Load file content
              const text = await fd.async("text");
              if (fullPath.endsWith(".xml")) {
                showLoading();
                xmlWorker.postMessage({text, path: fullPath, fileName});
              } else {
                fileCache[fullPath] = text;
                saveFileToDB(docxName + "/" + fullPath, text);
                openTab(fullPath, fileName, text, "plaintext");
              }
            });
          }
          ul.appendChild(li);
        });
      return ul;
    }

    /* -------------------- Recursive Search -------------------- */
    function filterTree(query, ulElement) {
      let anyVisible = false;
      ulElement.querySelectorAll(":scope > li").forEach((li) => {
        const name =
          li.querySelector(".fileName")?.textContent.toLowerCase() || "";
        const childUl = li.querySelector("ul");
        let childVisible = false;
        if (childUl) childVisible = filterTree(query, childUl);
        const match = name.includes(query);
        li.style.display = match || childVisible ? "block" : "none";
        anyVisible = anyVisible || match || childVisible;
      });
      return anyVisible;
    }
    fileSearch.addEventListener("input", () => {
      const query = fileSearch.value.toLowerCase();
      const topUl = fileTreeDiv.querySelector("ul");
      if (topUl) filterTree(query, topUl);
    });

    /* -------------------- Tab Management -------------------- */
    function renderTabs() {
      tabsContainer.innerHTML = "";
      openTabs.forEach((tab) => {
        const tabEl = document.createElement("div");
        tabEl.className = "tab" + (tab.path === activeTabPath ? " active" : "");

        const label = document.createElement("span");
        label.className = "tab-label";
        label.textContent = tab.name;
        label.title = tab.path;

        const closeBtn = document.createElement("span");
        closeBtn.className = "tab-close";
        closeBtn.innerHTML = "×";
        closeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          closeTab(tab.path);
        });

        tabEl.appendChild(label);
        tabEl.appendChild(closeBtn);
        tabEl.addEventListener("click", () => switchToTab(tab.path));
        tabsContainer.appendChild(tabEl);
      });
    }

    function openTab(path, name, content, type) {
      const existingTab = openTabs.find(t => t.path === path);
      if (existingTab) {
        switchToTab(path);
        return;
      }

      // Save current tab's scroll state before opening new tab
      if (activeTabPath && monacoEditor) {
        const currentTab = openTabs.find(t => t.path === activeTabPath);
        if (currentTab && currentTab.type !== "image") {
          currentTab.viewState = monacoEditor.saveViewState();
        }
      }

      openTabs.push({path, name, content, type});
      activeTabPath = path;
      renderTabs();
      displayContent(content, type);
    }

    function closeTab(path) {
      const index = openTabs.findIndex(t => t.path === path);
      if (index === -1) return;

      openTabs.splice(index, 1);

      if (activeTabPath === path) {
        if (openTabs.length > 0) {
          const newActiveTab = openTabs[Math.max(0, index - 1)];
          activeTabPath = newActiveTab.path;
          displayContent(newActiveTab.content, newActiveTab.type, newActiveTab.viewState);
        } else {
          activeTabPath = null;
          editorContainer.style.display = "";
          imageContainer.style.display = "none";
          if (monacoEditor) monacoEditor.setValue("");
        }
      }

      renderTabs();
    }

    function switchToTab(path) {
      const tab = openTabs.find(t => t.path === path);
      if (!tab) return;

      // Save current tab's scroll state before switching
      if (activeTabPath && monacoEditor) {
        const currentTab = openTabs.find(t => t.path === activeTabPath);
        if (currentTab && currentTab.type !== "image") {
          currentTab.viewState = monacoEditor.saveViewState();
        }
      }

      activeTabPath = path;
      renderTabs();
      displayContent(tab.content, tab.type, tab.viewState);
      updateFileTreeSelection(path);
    }

    function updateFileTreeSelection(path) {
      if (selectedFileLi) selectedFileLi.classList.remove("selected");

      const allFiles = fileTreeDiv.querySelectorAll("li.file");
      allFiles.forEach(li => {
        const labelDiv = li.querySelector(".labelContainer");
        if (labelDiv) {
          const fileNameSpan = labelDiv.querySelector(".fileName");
          if (fileNameSpan) {
            let currentPath = "";
            let node = li;
            const parts = [];

            while (node && node !== fileTreeDiv) {
              const nameSpan = node.querySelector(":scope > .labelContainer > .fileName");
              if (nameSpan) {
                parts.unshift(nameSpan.textContent);
              }
              node = node.parentElement?.closest("li");
            }

            currentPath = parts.join("/");

            if (currentPath === path) {
              li.classList.add("selected");
              selectedFileLi = li;
            }
          }
        }
      });
    }

    function displayContent(content, type, viewState) {
      if (type === "image") {
        editorContainer.style.display = "none";
        imageContainer.style.display = "flex";
        docxImage.src = content;
      } else {
        imageContainer.style.display = "none";
        editorContainer.style.display = "";
        displayFileInMonaco(content, type, viewState);
      }
    }

    /* -------------------- Editor & XML Worker -------------------- */
    function showLoading() {
      editorLoading.style.display = "flex";
    }
    function hideLoading() {
      editorLoading.style.display = "none";
    }
    function displayFileInMonaco(content, language, viewState) {
      editorContainer.style.display = "";
      if (monacoEditor) {
        if (!monacoEditor.getModel()) {
          const model = monaco.editor.createModel(content, "xml");
          monacoEditor.setModel(model);
        } else {
          monaco.editor.setModelLanguage(monacoEditor.getModel(), "xml");
          monacoEditor.setValue(content);
        }

        // Restore scroll position if available, otherwise go to top
        if (viewState) {
          monacoEditor.restoreViewState(viewState);
          monacoEditor.focus();
        } else {
          monacoEditor.revealPosition({lineNumber: 1, column: 1});
        }
      }
    }

    /* -------------------- XML Formatting Worker -------------------- */
    (function initWorker() {
      const blob = new Blob(
        [
          `
        importScripts('https://cdn.jsdelivr.net/npm/xml-formatter@3.6.7/dist/browser/xml-formatter-singleton.js');
        self.onmessage = function(e){
          const { text, path } = e.data;
          try {
            const formatted = xmlFormatter(text);
            self.postMessage({ success:true, formatted, path });
          } catch(err){
            self.postMessage({ success:false, error: err.message, path });
          }
        };
      `,
        ],
        {type: "application/javascript"},
      );

      xmlWorker = new Worker(URL.createObjectURL(blob));

      xmlWorker.onmessage = function (e) {
        const {success, formatted, error, path, fileName} = e.data;
        if (success) {
          fileCache[path] = formatted;
          saveFileToDB(docxName + "/" + path, formatted);
          const name = fileName || path.split("/").pop();
          openTab(path, name, formatted, "xml");
        } else {
          const name = fileName || path.split("/").pop();
          openTab(path, name, "Error formatting XML: " + error, "plaintext");
        }
        hideLoading();
      };
    })();

    /* -------------------- Recent Files UI -------------------- */
    async function renderRecentFiles() {
      const recentFiles = await getRecentFiles();

      if (recentFiles.length === 0) {
        recentFilesList.innerHTML = '<div id="noRecentFiles">No recent files</div>';
        return;
      }

      recentFilesList.innerHTML = "";
      recentFiles.forEach((file) => {
        const item = document.createElement("div");
        item.className = "recentFileItem";
        item.setAttribute("role", "button");
        item.setAttribute("tabindex", "0");

        const icon = document.createElement("span");
        icon.className = "material-icons";
        icon.textContent = "description";

        const info = document.createElement("div");
        info.className = "recentFileInfo";

        const name = document.createElement("div");
        name.className = "recentFileName";
        name.textContent = file.name;

        const date = document.createElement("div");
        date.className = "recentFileDate";
        const fileDate = new Date(file.timestamp);
        date.textContent = fileDate.toLocaleDateString() + " " + fileDate.toLocaleTimeString();

        info.appendChild(name);
        info.appendChild(date);

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "material-icons recentFileDelete";
        deleteBtn.textContent = "close";
        deleteBtn.setAttribute("aria-label", "Delete " + file.name);
        deleteBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          await deleteRecentFile(file.name);
          await renderRecentFiles();
        });

        item.appendChild(icon);
        item.appendChild(info);
        item.appendChild(deleteBtn);

        const openFile = async () => {
          setActiveFileHeader(file.name);
          await handleFile(file.data, true);
          fullScreenOverlay.style.display = "none";
        };

        item.addEventListener("click", openFile);
        item.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            openFile();
          }
        });

        recentFilesList.appendChild(item);
      });
    }

    function setupMonaco() {
      require.config({
        paths: {
          vs: "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.53.0/min/vs",
        },
      });

      require(["vs/editor/editor.main"], function () {
        monacoEditor = monaco.editor.create(
          document.getElementById("editorContainer"),
          {
            value: "",
            language: "plaintext",
            theme: "vs-dark",
            automaticLayout: true,
            readOnly: true,
            minimap: {enabled: false},
            scrollBeyondLastLine: false,
          },
        );

        monaco.languages.registerFoldingRangeProvider("xml", {
          provideFoldingRanges: function (model) {
            const ranges = [];
            const stack = [];
            for (let i = 1; i <= model.getLineCount(); i++) {
              const line = model.getLineContent(i).trim();
              const open = line.match(/^<([a-zA-Z0-9:_-]+)(\s|>|$)/);
              const close = line.match(/^<\/([a-zA-Z0-9:_-]+)>/);
              if (open && !line.endsWith("/>"))
                stack.push({tag: open[1], start: i});
              else if (close && stack.length > 0) {
                const last = stack.pop();
                if (last.tag === close[1] && i > last.start)
                  ranges.push({
                    start: last.start,
                    end: i,
                    kind: monaco.languages.FoldingRangeKind.Region,
                  });
              }
            }
            return ranges;
          },
        });

        renderRecentFiles();
      });
    }
    document.addEventListener("DOMContentLoaded", setupMonaco);
  </script>
</body>

</html>
